# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

from __future__ import annotations

from pathlib import PurePath, PurePosixPath, PureWindowsPath

from .._osname import OSName

__all__ = [
    "PathMappingRule",
]


class PathMappingRule:
    """A PathMappingRule represents how to transform a valid rooted path to another
    valid rooted path within or across different platforms.

    This is useful for consolidating environments that refer to physical storage with
    different paths. Consider the following example:

    Given:
        - A Storage Device: "SharedStorage"
        - A Windows instance: "Env1" with "SharedStorage" mounted at "Z:\\movie1"
        - A Linux instance: "Env2" with "SharedStorage" mounted at "/mnt/shared/movie1"

    If "Env2" wanted to perform work generated by "Env1" that references "SharedStorage"
    then we need to apply the following transformation to paths that reference "SharedStorage"
    on "Env2":
        "Z:\\movie1" -> "/mnt/shared/movie1"

    Some nuance to consider is that paths valid on one system, may not be valid on another. ie.
        - Windows paths are capitalization/directory separator agnostic, whereas Posix is not
            "Z:/MOVIE1" is equivalent to "z:\\movie1"
        - Posix paths can have colons (":") and backslashes ("\\") in the filename whereas
            Windows cannot
        - When transforming a Windows path to Posix, any backslashes (directory separators)
            must be changed to forward slashes
        - Spurious slashes and single dots are collapsed, but ".." in paths are not,
            since this would change the meaning of a path in the face of symbolic links
    """

    _pure_source_path: PurePath
    _pure_destination_path: PurePath

    def __init__(
        self,
        *,
        source_path_format: str,
        source_path: str,
        destination_path: str,
        destination_os: str = OSName(),
    ):
        for label, value in (
            ("source_path_format", source_path_format),
            ("source_path", source_path),
            ("destination_path", destination_path),
        ):
            if not value:
                raise ValueError(f"{label} cannot be None or empty")

        self.source_path: str = source_path
        self.destination_path: str = destination_path
        self._source_path_format: str = OSName(
            source_path_format
        )  # Raises ValueError if not valid OS
        self._is_windows_source: bool = OSName.is_windows(self._source_path_format)

        self._destination_os: str = OSName(destination_os)  # Raises ValueError if not valid OS
        self._is_windows_destination: bool = OSName.is_windows(self._destination_os)

        if self._is_windows_source:
            self._pure_source_path = PureWindowsPath(self.source_path)
        else:
            self._pure_source_path = PurePosixPath(self.source_path)

        if self._is_windows_destination:
            self._pure_destination_path = PureWindowsPath(self.destination_path)
        else:
            self._pure_destination_path = PurePosixPath(self.destination_path)

    def __eq__(self, other):
        return (
            self.source_path == other.source_path
            and self.destination_path == other.destination_path
            and self._is_windows_source == other._is_windows_source
            and self._is_windows_destination == other._is_windows_destination
        )

    @staticmethod
    def from_dict(*, rule: dict[str, str]) -> PathMappingRule:
        """Builds a PathMappingRule given a dict with the fields required by __init__
        raises TypeError, ValueError: if rule is None, an empty dict, or nonvalid"""
        if not rule:
            raise ValueError("Empty path mapping rule")

        return PathMappingRule(**rule)

    def to_dict(self) -> dict[str, str]:
        """Builds a PathMappingRule given a dict with the fields required by __init__
        raises TypeError, ValueError: if rule is None, an empty dict, or nonvalid"""
        return {
            "source_path_format": self._source_path_format,
            "source_path": self.source_path,
            "destination_os": self._destination_os,
            "destination_path": self.destination_path,
        }

    def apply(self, *, path: str) -> tuple[bool, str]:
        """Applies the path mapping rule on the given path, if it matches the rule.
        Does not collapse ".." since symbolic paths could be used.

        Returns: tuple[bool, str] - indicating if the path matched the rule and the resulting
        mapped path. If it doesn't match, then it returns the original path unmodified.
        """
        pure_path = self._get_pure_path(path)
        if not self._is_match(pure_path=pure_path):
            return False, path

        return True, str(self._swap_source_for_dest(pure_path))

    def _is_match(self, *, pure_path: PurePath) -> bool:
        """Determines if the supplied path matches the path mapping rule"""
        return pure_path.is_relative_to(self._pure_source_path)

    def _get_pure_path(self, path: str) -> PurePath:
        """Assumes that the path received matches the source os of the rule"""
        if self._is_windows_source:
            return PureWindowsPath(path)
        else:
            return PurePosixPath(path)

    def _swap_source_for_dest(self, pure_path: PurePath) -> PurePath:
        """Given that pure_path matches the rule, return a PurePath where the source
        parts are swapped for the destination parts"""
        new_parts = (
            self._pure_destination_path.parts + pure_path.parts[len(self._pure_source_path.parts) :]
        )
        if self._is_windows_destination:
            return PureWindowsPath(*new_parts)
        else:
            return PurePosixPath(*new_parts)
